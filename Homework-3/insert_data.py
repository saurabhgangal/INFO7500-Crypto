#!/usr/bin/env python3
"""
Bitcoin Data Insertion Script
Matches the schema generated by json_to_sql.py
"""

import json
import sqlite3
import sys

def insert_block_data(db_file, json_file):
    # Load JSON data
    with open(json_file, 'r') as f:
        data = json.load(f)
    
    # Connect to database
    conn = sqlite3.connect(db_file)
    cursor = conn.cursor()
    
    try:
        print(f"üì¶ Processing block: {data['hash'][:16]}...")
        
        # Insert block data
        cursor.execute("""
            INSERT OR REPLACE INTO blocks 
            (hash, confirmations, size, strippedsize, weight, height, version, 
             versionHex, merkleroot, time, mediantime, nonce, bits, difficulty, 
             chainwork, nTx, previousblockhash, nextblockhash)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            data['hash'],
            data.get('confirmations'),
            data.get('size'),
            data.get('strippedsize'),
            data.get('weight'),
            data.get('height'),
            data.get('version'),
            data.get('versionHex'),
            data.get('merkleroot'),
            data.get('time'),
            data.get('mediantime'),
            data.get('nonce'),
            data.get('bits'),
            data.get('difficulty'),
            data.get('chainwork'),
            data.get('nTx'),
            data.get('previousblockhash'),
            data.get('nextblockhash')
        ))
        
        print("‚úÖ Block data inserted")
        
        # Insert transactions
        for i, tx in enumerate(data.get('tx', [])):
            print(f"  üí≥ Processing transaction {i+1}/{len(data['tx'])}: {tx['txid'][:16]}...")
            
            # Insert transaction
            cursor.execute("""
                INSERT OR REPLACE INTO transactions
                (block_hash, txid, hash, version, size, vsize, weight, locktime, hex, fee)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                data['hash'],  # block_hash
                tx['txid'],
                tx.get('hash', tx['txid']),
                tx.get('version'),
                tx.get('size'),
                tx.get('vsize'),
                tx.get('weight'),
                tx.get('locktime'),
                tx.get('hex'),
                tx.get('fee')
            ))
            
            # Insert transaction inputs
            for j, vin in enumerate(tx.get('vin', [])):
                cursor.execute("""
                    INSERT INTO transaction_inputs
                    (txid, coinbase, sequence)
                    VALUES (?, ?, ?)
                """, (
                    tx['txid'],
                    vin.get('coinbase'),  # This will be None for non-coinbase transactions
                    vin.get('sequence')
                ))
            
            # Insert transaction outputs  
            for j, vout in enumerate(tx.get('vout', [])):
                script_pubkey = vout.get('scriptPubKey', {})
                addresses = script_pubkey.get('addresses', [])
                addresses_json = json.dumps(addresses) if addresses else None
                
                cursor.execute("""
                    INSERT INTO transaction_outputs
                    (txid, value, n, scriptpubkey_asm, scriptpubkey_hex, 
                     scriptpubkey_reqSigs, scriptpubkey_type, scriptpubkey_addresses)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    tx['txid'],
                    vout.get('value'),
                    vout.get('n'),
                    script_pubkey.get('asm'),
                    script_pubkey.get('hex'),
                    script_pubkey.get('reqSigs'),
                    script_pubkey.get('type'),
                    addresses_json
                ))
        
        conn.commit()
        print("üéâ All data inserted successfully!")
        
        # Show summary
        cursor.execute("SELECT COUNT(*) FROM blocks")
        block_count = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM transactions")
        tx_count = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM transaction_inputs")
        input_count = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM transaction_outputs")
        output_count = cursor.fetchone()[0]
        
        print("\nüìä Database Summary:")
        print(f"   Blocks: {block_count}")
        print(f"   Transactions: {tx_count}")
        print(f"   Inputs: {input_count}")
        print(f"   Outputs: {output_count}")
    
    except Exception as e:
        print(f"‚ùå Error: {e}")
        conn.rollback()
        raise
    finally:
        conn.close()

def main():
    if len(sys.argv) != 3:
        print("Usage: python insert_data.py <database_file> <json_file>")
        print("Example: python insert_data.py bitcoin.db sample_block.json")
        sys.exit(1)
    
    db_file = sys.argv[1]
    json_file = sys.argv[2]
    
    # Check if database exists
    try:
        conn = sqlite3.connect(db_file)
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = [row[0] for row in cursor.fetchall()]
        conn.close()
        
        if not tables:
            print("‚ùå Database has no tables. Please create the schema first:")
            print("   sqlite3 bitcoin.db < bitcoin_schema.sql")
            sys.exit(1)
            
        print(f"‚úÖ Database found with tables: {', '.join(tables)}")
        
    except Exception as e:
        print(f"‚ùå Database error: {e}")
        sys.exit(1)
    
    # Insert data
    insert_block_data(db_file, json_file)

if __name__ == "__main__":
    main()
