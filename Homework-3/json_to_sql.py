#!/usr/bin/env python3
"""
JSON to SQL Schema Generator
Automatically generates SQLite schema from JSON objects, specifically designed for Bitcoin getblock data.
"""

import json
import sys
import re
from typing import Dict, Any, List, Set, Tuple

class JSONToSQLGenerator:
    def __init__(self):
        self.type_mapping = {
            int: 'INTEGER',
            float: 'REAL',
            str: 'TEXT',
            bool: 'INTEGER',  # SQLite stores booleans as integers
            list: 'TEXT',     # Store as JSON text
            dict: 'TEXT',     # Store as JSON text
            type(None): 'TEXT'
        }
        
    def analyze_json_structure(self, obj: Any, path: str = "") -> Dict[str, Dict]:
        """Recursively analyze JSON structure to determine field types and relationships."""
        analysis = {}
        
        if isinstance(obj, dict):
            for key, value in obj.items():
                current_path = f"{path}.{key}" if path else key
                
                if isinstance(value, dict):
                    # Nested object - might need separate table
                    analysis[current_path] = {
                        'type': 'OBJECT',
                        'sql_type': 'TEXT',
                        'is_nested': True,
                        'nested_fields': self.analyze_json_structure(value, current_path)
                    }
                elif isinstance(value, list):
                    if value and isinstance(value[0], dict):
                        # Array of objects - definitely needs separate table
                        analysis[current_path] = {
                            'type': 'ARRAY_OF_OBJECTS',
                            'sql_type': 'TEXT',
                            'is_array': True,
                            'array_item_structure': self.analyze_json_structure(value[0], f"{current_path}_item")
                        }
                    else:
                        # Array of primitives - store as JSON text
                        analysis[current_path] = {
                            'type': 'ARRAY',
                            'sql_type': 'TEXT',
                            'is_array': True,
                            'array_item_type': type(value[0]) if value else str
                        }
                else:
                    # Primitive value
                    analysis[current_path] = {
                        'type': type(value).__name__,
                        'sql_type': self.type_mapping.get(type(value), 'TEXT'),
                        'is_nested': False,
                        'is_array': False,
                        'sample_value': value
                    }
        
        return analysis
    
    def generate_table_schema(self, table_name: str, fields: Dict[str, Dict], 
                            primary_key: str = None, foreign_keys: List[Tuple[str, str, str]] = None) -> str:
        """Generate CREATE TABLE statement for a given set of fields."""
        
        lines = [f"CREATE TABLE {table_name} ("]
        
        # Add ID field for tables that need it
        if table_name not in ['blocks'] and not primary_key:
            lines.append("    id INTEGER PRIMARY KEY AUTOINCREMENT,")
        
        # Add fields
        for field_name, field_info in fields.items():
            # Clean field name for SQL
            clean_name = re.sub(r'[^a-zA-Z0-9_]', '_', field_name.split('.')[-1])
            sql_type = field_info['sql_type']
            
            # Add constraints
            constraints = []
            if field_name == primary_key:
                constraints.append("PRIMARY KEY")
            if field_name in ['hash', 'txid'] and 'hash' in field_name.lower():
                constraints.append("NOT NULL")
                
            constraint_str = " " + " ".join(constraints) if constraints else ""
            lines.append(f"    {clean_name} {sql_type}{constraint_str},")
        
        # Add timestamp
        lines.append("    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,")
        
        # Add foreign keys
        if foreign_keys:
            for fk_field, ref_table, ref_field in foreign_keys:
                lines.append(f"    FOREIGN KEY ({fk_field}) REFERENCES {ref_table}({ref_field}),")
        
        # Remove last comma and close
        if lines[-1].endswith(','):
            lines[-1] = lines[-1][:-1]
        
        lines.append(");")
        return "\n".join(lines)
    
    def generate_bitcoin_schema(self, getblock_json: Dict[str, Any]) -> str:
        """Generate complete Bitcoin schema from getblock JSON with verbosity=2."""
        
        schema_parts = []
        schema_parts.append("-- Auto-generated Bitcoin Schema from getblock JSON")
        schema_parts.append("-- Generated by JSON to SQL Schema Generator\n")
        
        # Analyze the structure
        analysis = self.analyze_json_structure(getblock_json)
        
        # 1. Generate blocks table (main block data)
        block_fields = {}
        transaction_array_info = None
        
        for field_path, field_info in analysis.items():
            if field_path == 'tx':
                transaction_array_info = field_info
            elif not field_info.get('is_nested', False) and not field_info.get('is_array', False):
                block_fields[field_path] = field_info
        
        blocks_schema = self.generate_table_schema('blocks', block_fields, primary_key='hash')
        schema_parts.append(blocks_schema)
        schema_parts.append("")
        
        # 2. Generate transactions table
        if transaction_array_info and 'array_item_structure' in transaction_array_info:
            tx_structure = transaction_array_info['array_item_structure']
            
            tx_fields = {'block_hash': {'sql_type': 'TEXT', 'type': 'str'}}  # FK to blocks
            vin_info = None
            vout_info = None
            
            for field_path, field_info in tx_structure.items():
                field_name = field_path.split('.')[-1]
                if field_name == 'vin':
                    vin_info = field_info
                elif field_name == 'vout':
                    vout_info = field_info
                elif not field_info.get('is_nested', False) and not field_info.get('is_array', False):
                    tx_fields[field_name] = field_info
            
            tx_schema = self.generate_table_schema(
                'transactions', 
                tx_fields, 
                primary_key='txid',
                foreign_keys=[('block_hash', 'blocks', 'hash')]
            )
            schema_parts.append(tx_schema)
            schema_parts.append("")
            
            # 3. Generate transaction_inputs table (vin)
            if vin_info and 'array_item_structure' in vin_info:
                vin_fields = {'txid': {'sql_type': 'TEXT', 'type': 'str'}}  # FK to transactions
                for field_path, field_info in vin_info['array_item_structure'].items():
                    if not field_info.get('is_nested', False):
                        field_name = field_path.split('.')[-1]
                        vin_fields[field_name] = field_info
                
                vin_schema = self.generate_table_schema(
                    'transaction_inputs',
                    vin_fields,
                    foreign_keys=[('txid', 'transactions', 'txid')]
                )
                schema_parts.append(vin_schema)
                schema_parts.append("")
            
            # 4. Generate transaction_outputs table (vout)
            if vout_info and 'array_item_structure' in vout_info:
                vout_fields = {'txid': {'sql_type': 'TEXT', 'type': 'str'}}  # FK to transactions
                for field_path, field_info in vout_info['array_item_structure'].items():
                    field_name = field_path.split('.')[-1]
                    if field_name == 'scriptPubKey' and field_info.get('is_nested'):
                        # Flatten scriptPubKey fields
                        if 'nested_fields' in field_info:
                            for nested_field, nested_info in field_info['nested_fields'].items():
                                clean_name = f"scriptpubkey_{nested_field.split('.')[-1]}"
                                vout_fields[clean_name] = nested_info
                    elif not field_info.get('is_nested', False):
                        vout_fields[field_name] = field_info
                
                vout_schema = self.generate_table_schema(
                    'transaction_outputs',
                    vout_fields,
                    foreign_keys=[('txid', 'transactions', 'txid')]
                )
                schema_parts.append(vout_schema)
                schema_parts.append("")
        
        # 5. Add indexes
        indexes = [
            "CREATE INDEX idx_blocks_height ON blocks(height);",
            "CREATE INDEX idx_blocks_time ON blocks(time);",
            "CREATE INDEX idx_transactions_block_hash ON transactions(block_hash);",
            "CREATE INDEX idx_transaction_inputs_txid ON transaction_inputs(txid);",
            "CREATE INDEX idx_transaction_outputs_txid ON transaction_outputs(txid);"
        ]
        
        schema_parts.append("-- Performance Indexes")
        schema_parts.extend(indexes)
        
        return "\n".join(schema_parts)
    
    def generate_from_json_file(self, json_file_path: str) -> str:
        """Generate schema from a JSON file."""
        with open(json_file_path, 'r') as f:
            data = json.load(f)
        return self.generate_bitcoin_schema(data)
    
    def generate_from_json_string(self, json_string: str) -> str:
        """Generate schema from a JSON string."""
        data = json.loads(json_string)
        return self.generate_bitcoin_schema(data)

def main():
    generator = JSONToSQLGenerator()
    
    if len(sys.argv) < 2:
        print("Usage: python json_to_sql.py <json_file_or_string>")
        print("\nExample usage:")
        print("1. From file: python json_to_sql.py block_data.json")
        print("2. From Bitcoin CLI: bitcoin-cli getblock $(bitcoin-cli getbestblockhash) 2 | python json_to_sql.py -")
        return
    
    input_source = sys.argv[1]
    
    try:
        if input_source == '-':
            # Read from stdin
            json_string = sys.stdin.read()
            schema = generator.generate_from_json_string(json_string)
        else:
            # Read from file
            schema = generator.generate_from_json_file(input_source)
        
        print(schema)
        
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
